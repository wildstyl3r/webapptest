<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Mirror App</title>
    <style>
        body { 
            margin: 0; padding: 0; 
            background: #000; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            font-family: sans-serif; 
        }
        #video { 
            max-width: 100%; 
            max-height: 100%; 
            object-fit: cover; 
            transform: scaleX(-1); /* Mirror flip */
        }
        #controls { 
            position: absolute; 
            bottom: 20px; 
            text-align: center; 
            color: white; 
        }
        button { 
            background: #0088cc; 
            color: white; 
            border: none; 
            padding: 12px 24px; 
            border-radius: 8px; 
            font-size: 16px; 
            cursor: pointer; 
        }
    </style>
</head>
<body>
    <video id="video" autoplay muted playsinline></video>
    <div id="controls">
        <button onclick="toggleCamera()">Switch Camera</button>
        <p>Front camera mirror</p>
    </div>

    <script>
        const video = document.getElementById('video');
        let stream = null;
        let currentTrack = null;
        let backTrack = null;
        let isFrontCamera = true;

        async function initCamera() {
            try {
                // Start with front camera ONLY (known to work)
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                currentTrack = stream.getVideoTracks()[0];
                video.srcObject = stream;
                
                // Find back camera for later switching (no permission needed to enumerate)
                const devices = await navigator.mediaDevices.enumerateDevices();
                // let listDevices = devices.filter(device => 
                //     device.kind === 'videoinput').map(device=>device.label).join(', ');
                // alert(listDevices);
                backTrack = devices.find(device => 
                    device.kind === 'videoinput' && 
                    device.label.toLowerCase().includes('back') || 
                    !device.label.toLowerCase().includes('front')
                );
                alert(backTrack.label);
                
            } catch (err) {
                alert('Front camera access denied: ' + err.message);
            }
        }

        async function switchToBackCamera() {
            try {
                if (!backTrack || !backTrack.deviceId) {
                    alert('Back camera not found');
                    return;
                }
                
                // Stop current track, get new back camera track
                currentTrack.stop();
                
                // Get back camera with SAME permissions context
                const newStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        deviceId: { exact: backTrack.deviceId },
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 } 
                    }
                });
                
                currentTrack = newStream.getVideoTracks()[0];
                stream.removeTrack(stream.getVideoTracks()[0]);
                stream.addTrack(currentTrack);
                video.srcObject = stream;
                
                video.style.transform = 'none'; // No mirror for back
                isFrontCamera = false;
                
            } catch (err) {
                alert('Back camera failed: ' + err.message);
            }
        }

        function toggleCamera() {
            if (isFrontCamera) {
                switchToBackCamera();
            } else {
                // Switch back to front (re-request works after initial grant)
                initCamera();
            }
        }

        // Telegram support
        if (window.Telegram?.WebApp) {
            Telegram.WebApp.ready();
            Telegram.WebApp.expand();
        }

        initCamera();
    </script>


</body>
</html>
